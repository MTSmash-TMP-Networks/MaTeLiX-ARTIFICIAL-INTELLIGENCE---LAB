<!DOCTYPE html>
<html lang="de">
<head>
  <title>MaTeLiX ARTIFICIAL INTELLIGENCE - LAB</title>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>

  <style>
:root {
  --matrix-bg: #101816;
  --card-bg: #16221c;
  --green: #32ff78;
  --green-soft: #1aff5b;
  --input-bg: #15291c;
  --text: #d0ffd8;
  --border: #276b3a;
  --shadow: 0 2px 18px 0 #14ff77aa;
  --shadow-soft: 0 1px 8px 0 #14ff7760;
}
html, body {
  margin:0; padding:0;
  background: radial-gradient(ellipse at 60% 0%, #13231e 0%, #101816 70%);
  color: var(--text);
  font-family: 'Segoe UI', 'Fira Sans', 'Roboto', Arial, sans-serif;
  min-height: 100vh;
  letter-spacing: 0.02em;
}

input, select, textarea {
  background: var(--input-bg);
  border: 1.5px solid #22ffb1;
  border-radius: 7px;
  color: var(--text);
  padding: 5px 10px;
  box-shadow: 0 0 8px #13e36420 inset;
  outline: none;
  transition: border 0.13s;
  font-family: 'Fira Mono', 'Consolas', monospace;
  font-size: 1em;
}
input:focus, select:focus, textarea:focus {
  border: 2px solid var(--green);
  background: #0c2e20;
}

button.danger {
  background: linear-gradient(90deg,#5f1212,#2a0606);
  color: #ffd4d4;
  border: 1.5px solid #ff6464;
  text-shadow: 0 0 4px #ff8f8f;
}
button.danger:hover, button.danger:focus {
  background: linear-gradient(90deg,#7a1a1a,#3a0a0a 80%);
  color: #fff;
  border-color: #ff8b8b;
}

#dashboard-header {
  background: linear-gradient(90deg, #093c21 0%, #16a36d 100%);
  padding: 2em 1.5em 1.5em 1.5em;
  margin-bottom:2.5em;
  box-shadow: var(--shadow);
  border-bottom: 2px solid var(--green);
  border-radius: 0 0 32px 32px;
  text-align: center;
  text-shadow: 0 0 12px var(--green-soft);
}
#dashboard-header h1 {
  font-family: 'Fira Mono', 'Consolas', monospace;
  font-size: 2.6em;
  color: var(--green);
  margin: 0 0 0.2em 0;
  letter-spacing: 0.03em;
  font-weight: 900;
  text-transform: uppercase;
  filter: brightness(1.4) drop-shadow(0 0 6px #18ff7d);
}
#dashboard-header span {
  font-size:1.15em;
  opacity:0.7;
}
#systemstatus {
  margin-bottom:2em;
  font-size:1.05em;
  text-align: center;
  opacity: 0.85;
}
#dashboard-main {
  display:flex;
  flex-wrap: wrap;
  gap:2.5em;
  align-items: flex-start;
  justify-content: center;
  margin: 0 1vw;
}
.card {
  background: var(--card-bg);
  border: 1.5px solid var(--border);
  border-radius: 22px;
  box-shadow: var(--shadow-soft);
  padding:2em 2em 1.6em 2em;
  margin-bottom:2em;
  min-width:360px; max-width:460px;
  flex: 1 1 380px;
  position: relative;
}
.card h2, .card h3 {
  color: var(--green);
  font-family: 'Fira Mono', 'Consolas', monospace;
  margin-top: 0;
  margin-bottom: .9em;
  text-shadow: 0 0 6px var(--green);
  font-weight: 700;
}
.status, .card .status {
  margin:1em 0 1.7em 0;
  font-size:1.1em;
  background:rgba(40,255,80,0.06);
  border-radius:7px;
  padding:0.8em 1.1em;
  box-shadow:0 0 6px #1aff5b13;
}

/* === SETTINGS-GRID TRAINING === */
.settings-grid {
  display: grid;
  grid-template-columns: 140px 1fr;
  gap: 0.55em 1.1em;
  align-items: center;
  max-width: 520px;
  margin: 0 auto 1.4em auto;
}
.settings-grid label {
  justify-self: start;
  color: #8fffbc;
  font-weight: 500;
  font-size: 1.01em;
  margin-bottom: 0;
  text-align: left;
  white-space:nowrap;
  letter-spacing: 0.015em;
}
.settings-grid input,
.settings-grid select {
  width: 55%;
  min-width: 0;
  margin-bottom: 0;
  justify-self: end;
}
.settings-grid button { margin-top: 0.2em; }
.settings-grid [style*="display:none"] { display: none !important; }

@media (max-width:700px) {
  .card { padding:1em 0.8em; font-size:94%; }
  .settings-grid {
    grid-template-columns: 1fr;
    max-width: 99vw;
    gap: 0.55em 0.7em;
  }
  .settings-grid label { margin-top: 0.7em; }
  .settings-grid input,
  .settings-grid select {
    width: 100%;
    justify-self: stretch;
  }
}

/* --- GLOBALE BUTTONS IM MATRIX-DESIGN --- */
button {
  background: linear-gradient(90deg,#1ed976 10%,#064c25 90%);
  color: #0fffa8;
  border: 1.5px solid var(--green);
  border-radius: 8px;
  padding: 0.4em 1.3em;
  font-size: 1em;
  font-weight: bold;
  cursor: pointer;
  box-shadow: 0 0 14px #22ffb922;
  transition: background .14s, color .14s;
  text-shadow:0 0 4px #15ffb1;
  font-family: 'Fira Mono', 'Consolas', monospace;
  margin-top: .3em;
}
button:hover, button:focus {
  background: linear-gradient(90deg,#19ff8a,#094a2f 80%);
  color: #000;
  border-color: #47ffa0;
}

/* --- KLEINE SPEZIAL-KLASSE FÜR DOWNLOAD-BUTTONS --- */
button.download-btn {
  font-size: 0.93em;
  padding: 0.25em 0.9em;
  background: #07271a;
  color: #19ff90;
  border: 1.3px solid #13ff7e;
  box-shadow: 0 0 8px #13ff7e44;
  margin-left: 1em;
  margin-top: 0.1em;
}
button.download-btn:hover, button.download-btn:focus {
  background: #09361f;
  color: #aaffcb;
}

/* --- Weitere Styles --- */
form label { font-family: 'Fira Mono', 'Consolas', monospace; }
form label {
  margin: 8px 4px 8px 0;
  display:inline-block;
}
.card pre {
  white-space: pre-wrap;
  word-break: break-all;
  overflow-x: auto;
  max-width: 100%;
  box-sizing: border-box;
}
#logbox {
  background: #07271a;
  color: #87ffa7;
  width: 99%;
  height: 31vh;
  border-radius: 13px;
  border:1px solid #27ff7d55;
  padding: 1em;
  font-family: 'Fira Mono', 'Consolas', monospace;
  font-size: 1.03em;
  overflow-y: scroll;
  margin-bottom: 0.6em;
  box-shadow:0 0 12px #18ff4c18;
}
#lossChart {
  width: 100% !important;
  background: #091f12;
  border-radius: 10px;
  margin-bottom:1.3em;
  border:1.3px solid #20ff70a8;
  box-shadow:0 0 9px #00ffb310;
}
#livepreviewBox {
  background:#001e0d;
  border-radius:10px;
  padding:1.2em;
  min-height:95px;
  border:1.2px solid #22ff7faa;
  box-shadow:0 0 12px #15ff7c22;
  margin-top:1.2em;
}
#livepreview {
  white-space:pre-wrap;
  font-family:'Fira Mono','Consolas',monospace;
  font-size:1.07em;
  color:#19ff67;
  min-height:36px;
}
#togglePreviewBtn {
  margin-top:0.5em;
  float:right;
  background:#011e11;
  border:1px solid #27ffae;
  color:#1aff83;
  font-size:1em;
  padding:0.1em 1.2em;
  border-radius:8px;
  box-shadow:0 0 8px #1aff7c33;
  cursor:pointer;
  transition:.13s;
}
#togglePreviewBtn:hover {
  background: #083c22;
  color: #2fffa0;
}

/* --- Matrix Spinner Overlay --- */
#matrix-spinner-overlay {
  display: none;
  position: fixed;
  z-index: 1000;
  left:0; top:0; width:100vw; height:100vh;
  background: rgba(7,18,12,0.85);
  backdrop-filter: blur(2px);
  justify-content: center; align-items: center;
}
#matrix-spinner-content {
  text-align:center;
  padding:2.2em 2.7em 2.2em 2.7em;
  background: #0a1d16cc;
  border-radius: 25px;
  box-shadow: 0 0 80px #1cff99aa, 0 0 16px #000;
  border: 2.5px solid #2fffaa;
}
#model_dir_select { width: 60%; min-width: 0; box-sizing: border-box; }
.matrix-loader {
  margin:0 auto 1.6em auto;
  display:block;
  width:64px; height:64px;
  position:relative;
}
.matrix-loader::before, .matrix-loader::after {
  content:'';
  display:block;
  position:absolute;
  top:0; left:0; width:100%; height:100%;
  border-radius:50%;
  border:4px solid #25ff95;
  opacity:0.7;
  animation: matrix-spin 1.1s linear infinite;
  box-shadow:0 0 18px #1cff97, 0 0 36px #0aff6e40;
}
.matrix-loader::after {
  border-color: #11ff55 transparent #11ff55 transparent;
  opacity:1;
  animation: matrix-spin 0.7s linear infinite reverse;
  box-shadow: 0 0 22px #1cff99;
}
@keyframes matrix-spin {
  0% { transform: rotate(0deg);}
  100% { transform: rotate(360deg);}
}
#matrix-spinner-label {
  color: #2fff9b;
  font-family:'Fira Mono','Consolas',monospace;
  font-size:1.34em;
  text-shadow:0 0 16px #12ff79;
  margin-bottom:0;
  margin-top:0.5em;
  letter-spacing:0.04em;
  animation: flicker 1.6s infinite alternate;
}
#matrix-bg-canvas {
  position: fixed;
  left: 0; top: 0;
  width: 100vw;
  height: 100vh;
  z-index: 0;
  pointer-events: none;
  opacity: 0.18;
  filter: blur(0.6px) brightness(1.5);
}
#ekg-bg-canvas {
  position: fixed;
  left: 0; top: 0;
  width: 100vw;
  height: 100vh;
  z-index: 1;
  pointer-events: none;
  opacity: 0.21;
}

#dashboard-header, #systemstatus, #dashboard-main, .card {
  position: relative;
  z-index: 2;
}
@keyframes flicker { 0% { opacity:1;} 100% { opacity:0.7;} }

@media (max-width:1100px) {
  #dashboard-main { flex-direction:column; gap:1.3em; }
  .card { max-width:99vw; min-width:95vw;}
}

/* --- Footer --- */
#site-footer {
  background: #0b1c14;
  border-top: 2px solid var(--green);
  text-align: center;
  padding: 1.2em 0;
  margin-top: 3em;
  color: var(--text);
  font-size: 0.95em;
  box-shadow: 0 -2px 14px #14ff7740;
  position: relative;
  z-index: 3;
}
#site-footer p {
  margin: 0;
  color: #18ff7d;
  text-shadow: 0 0 4px #14ff7760;
  font-family: 'Fira Mono', 'Consolas', monospace;
  letter-spacing: 0.03em;
}
  </style>
</head>

<body>
<canvas id="matrix-bg-canvas"></canvas>
<canvas id="ekg-bg-canvas"></canvas>

<div id="dashboard-header">
  <h1>MaTeLiX ARTIFICIAL INTELLIGENCE - LAB</h1>
  <span>LLM Trainer (Row-SFT, Chat + Text) – powered by TMP-SYSTEM-SERVICE GmbH</span>
</div>

<div id="systemstatus">
  <div style="display:flex; justify-content:center; gap:40px; align-items: flex-end;">
    <div>
      <canvas id="cpuGauge" width="100" height="50"></canvas>
      <div style="text-align:center; color:#32ff78; font-size:0.96em;">CPU</div>
    </div>
    <div>
      <canvas id="ramGauge" width="100" height="50"></canvas>
      <div style="text-align:center; color:#32ff78; font-size:0.96em;">RAM</div>
    </div>
    <div>
      <canvas id="gpuGauge" width="100" height="50"></canvas>
      <div style="text-align:center; color:#32ff78; font-size:0.96em;">GPU</div>
    </div>
  </div>
</div>

<div id="gauge-stats" style="text-align:center; margin-top:-12px; color:#44ffbe; font-size:1.08em;">
  RAM: <span id="ramStat">--</span> &nbsp;|&nbsp; GPU: <span id="gpuName">--</span> &nbsp;|&nbsp; GPU RAM: <span id="gpuRam">--</span> &nbsp;|&nbsp; #GPUs: <span id="numGpus">--</span>
</div>
<div id="all-gpus-list" style="text-align:center; margin:0.5em 0 1em 0; color:#00ffd7;"></div>

<div id="dashboard-main">
  <!-- TRAINING CARD -->
  <div class="card" style="max-width:520px;">
    <h2>Training Setup</h2>

    <form id="settings" autocomplete="off" class="settings-grid">
      <label for="model_dir_select">Modell wählen:</label>
      <select id="model_dir_select">
        <option value="MTSmash/EvaGPT-German-0.7B">EvaGPT-German-0.7B</option>
        <option value="custom">Anderes Modell (Pfad angeben)</option>
      </select>

      <label for="model_dir" id="model_dir_label" style="display:none;">Eigenes Modellverzeichnis:</label>
      <input type="text" id="model_dir" style="display:none;" placeholder="z.B. ./EvaGPT-500m/">

      <label for="csv_path_select">Trainingsdatei (CSV):</label>
      <select id="csv_path_select"></select>
      <input type="text" id="csv_path" style="display:none;" placeholder="Pfad zur CSV">

      <label for="save_dir">Speicher-Ordner (Basis):</label>
      <input type="text" id="save_dir" value="./training_outputs">

      <!-- TEMPLATE MODE -->
      <label for="template_mode">Vorlagen-Typ:</label>
      <select id="template_mode">
        <option value="chat" selected>Dialog (Chat-Template)</option>
        <option value="dialogplus">Dialog (Block-Template)</option>
        <option value="text">Nur Textspalte</option>
      </select>

      <!-- column_name nur bei text -->
      <label for="column_name" id="column_field" class="column_row" style="display:none;">Spaltenname:</label>
      <input type="text" id="column_name" value="text" class="column_row" style="display:none; width:10em;">

      <label for="learning_rate">Lernrate:</label>
      <input type="number" step="0.000001" id="learning_rate" value="0.0002">

      <label for="lr_schedule">Schedule:</label>
      <select id="lr_schedule">
        <option value="cosine" selected>Cosine</option>
        <option value="linear">Linear</option>
      </select>

      <label for="per_device_train_batch_size">Batchgröße:</label>
      <input type="number" id="per_device_train_batch_size" value="1" min="1">

      <label for="gradient_accumulation_steps">Gradient Acc. Steps:</label>
      <input type="number" id="gradient_accumulation_steps" value="8" min="1">

      <label for="num_train_epochs" title="Wie oft soll das gesamte Dataset durchlaufen werden?">Epochen:</label>
      <input type="number" id="num_train_epochs" value="3" step="0.5" min="0.5">

      <label for="max_steps" title="Optionales Hard-Limit (leer lassen = aus)">Max Steps:</label>
      <input type="number" id="max_steps" placeholder="(optional)" min="1">

      <label for="max_seq_length" title="Kontextfenster fürs Training (wichtig!)">Max Seq Length:</label>
      <input type="number" id="max_seq_length" value="1024" min="64">

      <label for="shuffle">Shuffle:</label>
      <input type="checkbox" id="shuffle">

      <label for="sort_by_length" title="Schneller: weniger Padding">Sort by Length:</label>
      <input type="checkbox" id="sort_by_length" checked>

      <!-- N-Gramm -->
      <label for="use_ngrams">N-Gramm-Optimierung:</label>
      <input type="checkbox" id="use_ngrams" title="Aktiviert N-Gramm-Tokenisierung für bessere Kompression">

      <label for="ngram_max" class="ngram_row" style="display:none;">Max N-Gramm-Länge:</label>
      <input type="number" id="ngram_max" class="ngram_row" style="display:none;" value="12" min="2" max="64">

      <label for="ngram_top_k" class="ngram_row" style="display:none;">Top-K N-Grams:</label>
      <input type="number" id="ngram_top_k" class="ngram_row" style="display:none;" value="1500" min="10">

      <label for="ngram_min_chars" class="ngram_row" style="display:none;">Min. Zeichen:</label>
      <input type="number" id="ngram_min_chars" class="ngram_row" style="display:none;" value="16" min="1">

      <label for="ngram_min_words" class="ngram_row" style="display:none;">Min. Wörter:</label>
      <input type="number" id="ngram_min_words" class="ngram_row" style="display:none;" value="2" min="0">

      <label for="ngram_max_samples" class="ngram_row" style="display:none;">Max Samples:</label>
      <input type="number" id="ngram_max_samples" class="ngram_row" style="display:none;" value="4000" min="100">

      <label for="ngram_budgeted" class="ngram_row" style="display:none;">Budget-gesteuert:</label>
      <input type="checkbox" id="ngram_budgeted" class="ngram_row" style="display:none;" checked title="Optimiert N-Grams für das Token-Budget">

      <label for="ngram_target_fit" class="ngram_row" style="display:none;">Ziel-Fit:</label>
      <input type="number" step="0.01" id="ngram_target_fit" class="ngram_row" style="display:none;" value="0.98" min="0.8" max="1.0">

      <label for="ngram_eval_samples" class="ngram_row" style="display:none;">Eval Samples:</label>
      <input type="number" id="ngram_eval_samples" class="ngram_row" style="display:none;" value="512" min="32">

      <label for="ngram_add_batch" class="ngram_row" style="display:none;">Add Batch:</label>
      <input type="number" id="ngram_add_batch" class="ngram_row" style="display:none;" value="64" min="1">
      <!-- Ende N-Gramm -->

      <label for="precision_mode">Precision:</label>
      <select id="precision_mode" title="fp16/bf16 nur auf CUDA; MPS/CPU immer FP32">
        <option value="auto" selected>auto</option>
        <option value="fp32">FP32</option>
        <option value="fp16">FP16 (nur CUDA)</option>
        <option value="bf16">BF16 (nur CUDA, falls unterstützt)</option>
      </select>

      <label for="gradient_checkpointing" title="Spart VRAM, kostet Laufzeit (nur sinnvoll CUDA).">Grad Checkpointing:</label>
      <input type="checkbox" id="gradient_checkpointing">

      <label for="device">Device:</label>
      <select id="device"></select>

      <label for="train_mode">Trainingsmodus:</label>
      <select id="train_mode">
        <option value="full">Vollständiges Training (alle Gewichte)</option>
        <option value="lora">Finetuning mit LoRA</option>
      </select>

      <label for="lora_r" class="lora_row" style="display:none;">LoRA r:</label>
      <input type="number" id="lora_r" value="8" class="lora_row" style="display:none; width:7em;" min="1">

      <label for="lora_alpha" class="lora_row" style="display:none;">LoRA Alpha:</label>
      <input type="number" id="lora_alpha" value="16" class="lora_row" style="display:none; width:7em;" min="1">

      <div></div>
      <div style="display: flex; gap:1.1em; flex-wrap:wrap;">
        <button type="submit">Training starten</button>
        <button type="button" id="stopBtn">Training stoppen</button>
      </div>
    </form>
  </div>

  <!-- STATUS + LOSS -->
  <div class="card" style="max-width:520px;">
    <h3>Status</h3>
    <div class="status">
      <b>Status:</b> <span id="status">-</span>
      <b>Step:</b> <span id="step">-</span>
      <b>Loss:</b> <span id="loss">-</span>
      <b>Lernrate:</b> <span id="learning_rate_display">-</span>
      <b>Restzeit:</b> <span id="eta">-</span>
      <b>Tokens/Step:</b> <span id="tokens_per_step">-</span>
      <b>Total Tokens:</b> <span id="total_tokens">-</span>
    </div>
    <h3>Loss-Kurve</h3>
    <canvas id="lossChart" height="250"></canvas>
    <h3>Aktuelles Trainings-Sample</h3>
    <div id="livepreviewBox">
      <div id="livepreview"></div>
      <button id="togglePreviewBtn" type="button">Mehr anzeigen</button>
    </div>
  </div>

  <!-- LOGS -->
  <div class="card" style="max-width:530px;">
    <h3>Logs</h3>
    <pre id="logbox"></pre>
  </div>

  <!-- TRAINING HISTORY -->
  <div class="card" style="max-width:650px;">
    <h3>Bisherige Trainingsläufe</h3>
    <div id="trainingsHistory"><i>Lade Trainingshistorie…</i></div>
  </div>

  <!-- CHAT -->
  <div class="card" style="max-width:650px;">
    <h3>Live-Chat mit geladenem Modell</h3>
    <div style="margin-bottom:0.8em;">
      <label for="chat_model_select" style="margin-right:0.6em;">Modell:</label>
      <select id="chat_model_select" style="max-width:320px;">
        <option value="">(letztes Training / aktuelles Inference-Modell)</option>
      </select>
      <label for="chat_device" style="margin-left:1em; margin-right:0.5em;">Device:</label>
      <select id="chat_device"></select>
      <button id="chat_load_btn" type="button" style="margin-left:0.8em;">Laden</button>
      <button id="chat_unload_btn" type="button" class="danger" style="margin-left:0.5em;">Entladen</button>
    </div>

    <textarea id="chat_system" placeholder="(optional) Systemprompt…" rows="2" style="width:95%;"></textarea>
    <div id="chat_history" style="height:260px; overflow:auto; background:#07271a; border:1px solid #27ff7d55; border-radius:10px; padding:0.8em; margin:0.8em 0;"></div>

    <div style="display:flex; gap:0.6em;">
      <input id="chat_input" type="text" placeholder="Nachricht eingeben…" style="flex:1; background:#15291c; border:1.5px solid #22ffb1; border-radius:7px; padding:8px;">
      <button id="chat_send_btn" type="button">Senden</button>
    </div>

    <div style="margin-top:0.8em; font-size:0.92em;">
      <label>max_new_tokens <input id="chat_max_new" type="number" value="256" style="width:70px;"></label>
      <label style="margin-left:1em;">temperature <input id="chat_temp" type="number" step="0.05" value="0.7" style="width:70px;"></label>
      <label style="margin-left:1em;">top_p <input id="chat_topp" type="number" step="0.05" value="0.9" style="width:70px;"></label>
    </div>
  </div>

  <!-- CSV FORMAT INFO -->
  <div class="card" style="max-width:650px; background:#0a1712; border:2px solid #13ff72; margin-bottom:2.5em;">
    <h3 style="margin-bottom:0.6em;">CSV-Dateiformate</h3>
    <div style="font-size:1.09em; color:#90ffc7;">
      <b>Dialog (chat / dialogplus):</b>
      <button type="button" onclick="downloadExample('chat')" class="download-btn">Beispiel-CSV herunterladen</button>
      <ul style="margin-top:0.3em; margin-bottom:0.8em;">
        <li><code>id</code> — eindeutige ID</li>
        <li><code>parent_id</code> — leer wenn kein Parent</li>
        <li><code>system</code> — optional</li>
        <li><code>Benutzer</code> — user message</li>
        <li><code>Kontext</code> — optional</li>
        <li><code>Assistentin</code> — target (Pflicht)</li>
      </ul>
      <pre style="background:#13231e; color:#14ff70; border-radius:6px; padding:0.7em;">
id,parent_id,system,Benutzer,Kontext,Assistentin
1,,Du bist ein freundlicher Chatbot.,Hallo!,,"Hallo! Wie kann ich dir helfen?"
2,1,,Wie spät ist es?,,"Ich habe keinen Zugriff auf deine Uhr, aber du kannst oben rechts schauen."
3,,Du bist Übersetzer.,Übersetze: "Guten Morgen",,Auf Englisch: "Good morning".
      </pre>

      <b>Nur-Text-Modus (template_mode=text):</b>
      <button type="button" onclick="downloadExample('text')" class="download-btn">Beispiel-CSV herunterladen</button>
      <pre style="background:#13231e; color:#17ff96; border-radius:6px; padding:0.7em;">
text
Das ist ein Beispielsatz für Pretraining.
Hier folgt eine weitere Trainingszeile.
      </pre>

      <div style="opacity:0.85; margin-top:0.6em;">
        <b>Hinweis:</b> Bei <code>template_mode=text</code> wird nur <code>column_name</code> genutzt; parent_id/History-Felder werden ignoriert.
      </div>
    </div>
  </div>

</div>

<footer id="site-footer">
  <p>© 2025 TMP-SYSTEM-SERVICE GmbH – Alle Rechte vorbehalten. Version 4.3</p>
</footer>

<div id="matrix-spinner-overlay">
  <div id="matrix-spinner-content">
    <span class="matrix-loader"></span>
    <div id="matrix-spinner-label">Training läuft ...<br>Bitte warten</div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
/* ========= Hintergrund (Matrix + EKG) ========= */
function resizeMatrixCanvas() {
  const c = document.getElementById('matrix-bg-canvas');
  if (!c) return;
  c.width = window.innerWidth;
  c.height = window.innerHeight;
}
window.addEventListener('resize', resizeMatrixCanvas);

function animateMatrixRain() {
  const canvas = document.getElementById('matrix-bg-canvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  const fontSize = 20;
  const columns = Math.max(1, Math.floor(w / fontSize));
  const drops = Array(columns).fill(0).map(() => Math.random() * h / fontSize);
  function draw() {
    ctx.fillStyle = "rgba(5,24,17,0.19)";
    ctx.fillRect(0, 0, w, h);
    ctx.font = fontSize + "px 'Fira Mono', Consolas, monospace";
    ctx.fillStyle = "#24ff82";
    for (let i = 0; i < drops.length; i++) {
      const text = String.fromCharCode(0x30A0 + Math.random() * 96);
      ctx.fillText(text, i * fontSize, drops[i] * fontSize);
      if (Math.random() > 0.983) drops[i] = 0;
      else drops[i] += 0.5 - Math.random() * 0.1;
    }
    requestAnimationFrame(draw);
  }
  draw();
}

function resizeEKGCanvas() {
  const canvas = document.getElementById('ekg-bg-canvas');
  if (!canvas) return;
  canvas.width = window.innerWidth;
  canvas.height = Math.floor(window.innerHeight * 0.14);
}
window.addEventListener('resize', resizeEKGCanvas);

function drawEKGLine(ctx, w, h, t) {
  const baseY = h * 0.72;
  const amp = h * 0.18;
  const step = 2;
  const bpm = 61 + Math.sin(t * 0.33) * 2.2;
  const period = 60 / bpm;
  const scrollSpeed = w / (8 * period);

  ctx.clearRect(0, 0, w, h);
  ctx.save();
  ctx.shadowColor = '#30ffab';
  ctx.shadowBlur = 14;
  ctx.lineWidth = 1.0;
  ctx.strokeStyle = "#39ff7d";
  ctx.beginPath();

  function randomSeed(n) {
    return Math.abs(Math.sin(n * 1123.2311 + n * n * 77.221)) % 1;
  }

  for (let x = 0; x <= w; x += step) {
    const t_x = t - (w - x) / scrollSpeed;
    const beatNumber = Math.floor(t_x / period);
    const eventRand = randomSeed(beatNumber);

    let event = "normal";
    if (eventRand > 0.92) event = "big";
    else if (eventRand > 0.88) event = "double";
    else if (eventRand > 0.85) event = "pause";
    else if (eventRand > 0.82) event = "noise";

    const peakMod = event === "big" ? 2.2 : 1;
    const isDouble = event === "double";
    const isPause = event === "pause";
    const isNoise = event === "noise";
    const peakNoise = 0.98 + 0.07 * Math.sin(beatNumber * 771.17);

    let beatPhase = (t_x % period) / period;
    if (beatPhase < 0) beatPhase += 1;

    let y = baseY;

    if (isPause) {
      y += Math.sin((x + t * 55) * 0.011) * amp * 0.10;
    } else {
      if (beatPhase > 0.02 && beatPhase < 0.045)
        y -= amp * 0.18 * Math.exp(-120 * Math.pow(beatPhase - 0.032, 2));
      else if (beatPhase > 0.055 && beatPhase < 0.068)
        y += amp * 0.12 * Math.exp(-280 * Math.pow(beatPhase - 0.060, 2));
      else if (beatPhase > 0.075 && beatPhase < 0.11)
        y -= amp * 1.05 * peakMod * peakNoise * Math.exp(-180 * Math.pow(beatPhase - 0.092, 2));
      else if (isDouble && beatPhase > 0.12 && beatPhase < 0.15)
        y -= amp * 0.85 * peakNoise * Math.exp(-110 * Math.pow(beatPhase - 0.134, 2));
      else if (beatPhase > 0.114 && beatPhase < 0.13)
        y += amp * 0.27 * Math.exp(-50 * Math.pow(beatPhase - 0.122, 2));
      else if (beatPhase > 0.16 && beatPhase < 0.23)
        y -= amp * 0.31 * Math.exp(-30 * Math.pow(beatPhase - 0.19, 2));

      if (isNoise) y += Math.sin((x + t * 210) * 0.093) * amp * 0.22;
    }

    y += Math.sin((x + t * 80) * 0.017) * amp * 0.08;
    y += (Math.random() - 0.5) * (isNoise ? 5 : 1.9);

    if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  }
  ctx.stroke();
  ctx.restore();
}

function animateEKG() {
  const canvas = document.getElementById('ekg-bg-canvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  let start = null;
  function frame(ts) {
    if (!start) start = ts;
    let t = (ts - start) / 1000;
    drawEKGLine(ctx, canvas.width, canvas.height, t);
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
}

window.addEventListener('DOMContentLoaded', function() {
  resizeMatrixCanvas();
  animateMatrixRain();
  resizeEKGCanvas();
  animateEKG();
});

/* ========= Helpers ========= */
function numberOrNull(v) {
  if (v === null || v === undefined) return null;
  const s = String(v).trim();
  if (!s) return null;
  const n = Number(s);
  return Number.isFinite(n) ? n : null;
}

function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
}
function escapeHtmlWithBreaks(s){
  return escapeHtml(s).replace(/\n/g, "<br>");
}

/* ========= Chat Devices ========= */
async function populateChatDevices() {
  const sel = document.getElementById('chat_device');
  sel.innerHTML = '';
  try {
    const hw = await (await fetch('/hardware')).json();
    const opts = [{v:'cpu', label:'CPU'}];
    if (hw.cuda) opts.push({v:'cuda', label:'CUDA'});
    if (hw.mps)  opts.push({v:'mps',  label:'MPS'});
    for (const o of opts) {
      const op = document.createElement('option');
      op.value = o.v; op.textContent = o.label;
      sel.appendChild(op);
    }
    sel.value = hw.cuda ? 'cuda' : (hw.mps ? 'mps' : 'cpu');
  } catch {
    const op = document.createElement('option');
    op.value = 'cpu'; op.textContent = 'CPU';
    sel.appendChild(op);
  }
}
window.addEventListener('DOMContentLoaded', populateChatDevices);

/* ========= Gauges (Chart.js robust) ========= */
let cpuGauge=null, ramGauge=null, gpuGauge=null;

function makeGauge(canvasEl, color) {
  if (!canvasEl || typeof Chart === 'undefined') return null;
  const ctx = canvasEl.getContext('2d');
  return new Chart(ctx, {
    type: 'doughnut',
    data: { datasets: [{ data: [0, 100], backgroundColor: [color, '#224133'], borderWidth: 0, cutout: '70%', circumference: 180, rotation: 270 }] },
    options: { responsive: false, plugins: { legend: { display: false }, tooltip: { enabled: false } }, animation: false }
  });
}

function setGaugeLabel(chart, label) {
  if (!chart) return;
  const ctx = chart.ctx;
  ctx.save();
  ctx.font = "bold 1.13em 'Fira Mono',monospace";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillStyle = "#32ff78";
  // kleiner Bereich in der Mitte
  ctx.clearRect(0, 0, chart.width, chart.height);
  // Chart neu zeichnen (doughnut) und dann Label drüber
  chart.draw();
  ctx.fillText(label, chart.width/2, chart.height/1.36);
  ctx.restore();
}

async function pollSysStatus(){
  if (!cpuGauge || !ramGauge || !gpuGauge) return;
  try{
    const d = await (await fetch('/sysstatus')).json();

    const cpuValue = Number(d.cpu_percent || 0);
    cpuGauge.data.datasets[0].data = [cpuValue, Math.max(0, 100-cpuValue)];
    cpuGauge.update('none');
    setGaugeLabel(cpuGauge, cpuValue.toFixed(0) + "%");

    const ramValue = Number(d.ram_percent || 0);
    ramGauge.data.datasets[0].data = [ramValue, Math.max(0, 100-ramValue)];
    ramGauge.update('none');
    setGaugeLabel(ramGauge, ramValue.toFixed(0) + "%");

    const gpuValue = (d.gpu_util ?? ((d.gpu_mem_used && d.gpu_mem) ? (d.gpu_mem_used/d.gpu_mem*100) : 0)) || 0;
    if (d.gpu_name && d.gpu_util != null) {
      gpuGauge.data.datasets[0].data = [gpuValue, Math.max(0, 100-gpuValue)];
      gpuGauge.update('none');
      setGaugeLabel(gpuGauge, Number(gpuValue).toFixed(0) + "%");
    } else {
      gpuGauge.data.datasets[0].data = [0, 100];
      gpuGauge.update('none');
      setGaugeLabel(gpuGauge, "n/a");
    }

    document.getElementById('ramStat').textContent = `${d.ram_used} / ${d.ram_total} MB (${d.ram_percent}%)`;
    document.getElementById('gpuName').textContent = d.gpu_name || "n/a";
    const gpuRamText = (d.gpu_mem && d.gpu_mem_used) ? `${d.gpu_mem_used} / ${d.gpu_mem} MB` : "n/a";
    document.getElementById('gpuRam').textContent = gpuRamText;
    document.getElementById('numGpus').textContent = d.num_cuda ?? 0;

    const allGpus = d.gpus || [];
    const gpusDiv = document.getElementById('all-gpus-list');
    if (allGpus.length > 1) {
      let html = "<b>Alle GPUs:</b><br><table style='margin:0 auto; color:#18ffb0; background:#13231e; border-radius:7px;'><tr><th style='padding:0 1em;'>#</th><th>Name</th><th>Mem</th><th>Util</th></tr>";
      allGpus.forEach((g,i) => {
        html += `<tr>
          <td style='text-align:right;'>GPU ${i}</td>
          <td>${escapeHtml(g.name)}</td>
          <td>${g.mem_used} / ${g.mem_total} MB</td>
          <td>${g.util}%</td>
        </tr>`;
      });
      html += "</table>";
      gpusDiv.innerHTML = html;
    } else if (allGpus.length === 1) {
      gpusDiv.innerHTML = `<b>GPU 0:</b> ${escapeHtml(allGpus[0].name)} (${allGpus[0].mem_used} / ${allGpus[0].mem_total} MB, ${allGpus[0].util}%)`;
    } else {
      gpusDiv.innerHTML = "";
    }
  }catch(e){
    cpuGauge.data.datasets[0].data = [0,100]; cpuGauge.update('none'); setGaugeLabel(cpuGauge, "?");
    ramGauge.data.datasets[0].data = [0,100]; ramGauge.update('none'); setGaugeLabel(ramGauge, "?");
    gpuGauge.data.datasets[0].data = [0,100]; gpuGauge.update('none'); setGaugeLabel(gpuGauge, "?");
  }
}

window.addEventListener('DOMContentLoaded', () => {
  cpuGauge = makeGauge(document.getElementById('cpuGauge'), '#32ff78');
  ramGauge = makeGauge(document.getElementById('ramGauge'), '#19f7ef');
  gpuGauge = makeGauge(document.getElementById('gpuGauge'), '#ffc800');

  // Wenn Chart.js nicht geladen werden kann, trotzdem UI nicht crashen
  if (!cpuGauge || !ramGauge || !gpuGauge) return;

  pollSysStatus();
  setInterval(pollSysStatus, 2000);
});

/* ========= Livepreview ========= */
let previewShort = "";
let previewFull  = "";
let previewExpanded = false;

async function pollLivePreview(){
  try {
    const d = await (await fetch('/livepreview')).json();
    previewShort = d.preview || "";
    previewFull  = d.preview_full || previewShort || "";
    renderPreview();
  } catch {}
}
function renderPreview(){
  const box = document.getElementById("livepreview");
  const btn = document.getElementById("togglePreviewBtn");
  if (!box || !btn) return;

  if (previewExpanded) {
    box.textContent = previewFull;
    btn.textContent = "Weniger anzeigen";
  } else {
    const base = previewShort || previewFull || "";
    const s = base.length > 200 ? base.slice(0, 200) + " ..." : base;
    box.textContent = s;
    btn.textContent = "Mehr anzeigen";
  }
}
document.getElementById("togglePreviewBtn").onclick = () => {
  previewExpanded = !previewExpanded;
  renderPreview();
};
setInterval(pollLivePreview, 2000);

/* ========= Status ========= */
async function getStatus(){
  try{
    const s = await (await fetch('/status')).json();
    document.getElementById("status").textContent = s.running ? "läuft" : "gestoppt";
    document.getElementById("step").textContent = (typeof s.step==="number" && s.step>0) ? s.step : "-";
    document.getElementById("loss").textContent = (typeof s.loss==="number" && s.loss>0) ? s.loss.toFixed(6) : "-";
    document.getElementById("learning_rate_display").textContent = (typeof s.learning_rate==="number") ? s.learning_rate : "-";
    document.getElementById("eta").textContent = s.eta || "-";
    document.getElementById("tokens_per_step").textContent = s.tokens_per_step || "-";
    document.getElementById("total_tokens").textContent = s.total_tokens || "-";
  } catch {}
}
getStatus(); setInterval(getStatus,1500);

/* ========= Loss Chart + Logs via WS (wss/ ws fix + reconnect) ========= */
window.lossData=[]; window.lossSteps=[];
let lossChart=null;

function initLossChart(){
  const canvas = document.getElementById('lossChart');
  if (!canvas || typeof Chart === 'undefined') return;
  const ctx = canvas.getContext('2d');
  lossChart = new Chart(ctx,{
    type:'line',
    data:{ labels:[], datasets:[{ label:'Loss', data:[], fill:false, borderColor:'#32ff78', tension:0.2, pointRadius:1.5 }] },
    options:{ responsive:false, animation:false, scales:{ x:{title:{display:true,text:'Step'},ticks:{color:'#1aff63'}}, y:{title:{display:true,text:'Loss'},ticks:{color:'#1aff63'}} } }
  });
}
function updateChart(){
  if (!lossChart) return;
  lossChart.data.labels = window.lossSteps;
  lossChart.data.datasets[0].data = window.lossData;
  lossChart.update('none');
}

function connectLogsWS(){
  const logbox = document.getElementById("logbox");
  if (!logbox) return;

  const proto = (location.protocol === 'https:') ? 'wss' : 'ws';
  let ws;
  try {
    ws = new WebSocket(`${proto}://${location.host}/ws/logs`);
  } catch {
    return;
  }

  ws.onmessage = evt => {
    logbox.textContent += evt.data + "\n";
    if (logbox.textContent.length > 200000) logbox.textContent = logbox.textContent.slice(-200000);
    logbox.scrollTop = logbox.scrollHeight;

    (evt.data || "").split('\n').forEach(line=>{
      const m = line.match(/Step (\d+)\s+\|\s+Loss:\s+([0-9\.eE\-]+)/);
      if(m){
        const step = Number(m[1]);
        const loss = Number(m[2]);
        if(!window.lossSteps.length || step>window.lossSteps[window.lossSteps.length-1]){
          window.lossSteps.push(step);
          window.lossData.push(loss);
          updateChart();
        }
      }
    });
  };

  ws.onclose = () => {
    // reconnect
    setTimeout(connectLogsWS, 1200);
  };
  ws.onerror = () => {
    try { ws.close(); } catch {}
  };
}

window.addEventListener('DOMContentLoaded', () => {
  initLossChart();
  connectLogsWS();
});

/* ========= Device Auswahl (Training) ========= */
let hw = {};
window.addEventListener('DOMContentLoaded', async () => {
  try { hw = await (await fetch('/hardware')).json(); }
  catch { hw = {cuda:false,mps:false}; }

  const sel = document.getElementById("device");
  sel.innerHTML = "";
  ["cpu","mps","cuda"].forEach(d => {
    if (d==="cpu" || (d==="mps"&&hw.mps) || (d==="cuda"&&hw.cuda)) {
      const o = document.createElement("option");
      o.value = d; o.textContent = d.toUpperCase();
      sel.appendChild(o);
    }
  });
  sel.value = hw.cuda ? "cuda" : (hw.mps ? "mps" : "cpu");
});

/* ========= UI Toggles ========= */
// LoRA Felder togglen
document.getElementById("train_mode").addEventListener("change", function() {
  const show = this.value === "lora";
  document.querySelectorAll('.lora_row').forEach(e => e.style.display = show ? "" : "none");
});

// N-Gramm-UI-Toggle
document.getElementById("use_ngrams").addEventListener("change", function() {
  const show = this.checked;
  document.querySelectorAll('.ngram_row').forEach(e => e.style.display = show ? "" : "none");
});
window.addEventListener('DOMContentLoaded', function() {
  document.querySelectorAll('.ngram_row').forEach(e => e.style.display = "none");
});

// template_mode toggles: column_name
function applyTemplateModeUI() {
  const mode = document.getElementById("template_mode").value;
  const isText = mode === "text";
  document.querySelectorAll('.column_row').forEach(e => e.style.display = isText ? "" : "none");
}
document.getElementById("template_mode").addEventListener("change", applyTemplateModeUI);
window.addEventListener('DOMContentLoaded', applyTemplateModeUI);

/* ========= Trainingshistorie ========= */
async function loadTrainings() {
  try {
    const res = await fetch('/trainings');
    const data = await res.json();
    const container = document.getElementById('trainingsHistory');
    if (!data.length) { container.innerHTML = "<i>Noch keine Trainingsdurchläufe gefunden.</i>"; return; }
    let html = "";
    for (const run of data.reverse()) {
      html += `
        <details style="margin-bottom:1.1em;">
          <summary><b>${escapeHtml(run.folder)}</b></summary>
          <pre style="max-height:220px; overflow:auto; background:#1a3525; border-radius:6px; padding:0.6em 0.9em;">${escapeHtml(JSON.stringify(run.config, null, 2))}</pre>
          <a href="/training_outputs/${encodeURIComponent(run.folder)}/train_config.json" download>Trainings-Config herunterladen</a>
        </details>
      `;
    }
    container.innerHTML = html;
  } catch (e) {
    document.getElementById('trainingsHistory').innerHTML = "<i>Fehler beim Laden der Historie.</i>";
  }
}
window.addEventListener('DOMContentLoaded', loadTrainings);

/* ========= Model Dropdown (Training) ========= */
async function fillModelDropdown() {
  const select = document.getElementById('model_dir_select');
  const prev = select.value;
  const staticOptions = Array.from(select.querySelectorAll('option[value="custom"], option[value^="MTSmash/"]'));

  let data = [];
  try {
    const res = await fetch('/available_models');
    data = await res.json();
  } catch {}

  select.innerHTML = '';
  staticOptions.forEach(o => select.appendChild(o));

  if (Array.isArray(data) && data.length) {
    const localGroup = document.createElement('optgroup');
    localGroup.label = "Eigene Trainingsmodelle";
    for (const folder of data.slice().reverse()) {
      const opt = document.createElement('option');
      opt.value = "./training_outputs/" + folder;
      opt.textContent = folder;
      localGroup.appendChild(opt);
    }
    select.appendChild(localGroup);
  }

  // restore selection if possible
  if ([...select.options].some(o => o.value === prev)) select.value = prev;
}
window.addEventListener('DOMContentLoaded', fillModelDropdown);

/* ========= Dataset Dropdown ========= */
async function fillDatasetDropdown() {
  const select = document.getElementById('csv_path_select');
  let data = [];
  try {
    const res = await fetch('/available_datasets');
    data = await res.json();
  } catch {}

  select.innerHTML = '';
  const customOpt = document.createElement('option');
  customOpt.value = "custom";
  customOpt.textContent = "Pfad manuell eingeben …";
  select.appendChild(customOpt);

  if (Array.isArray(data) && data.length) {
    for (const csv of data) {
      const opt = document.createElement('option');
      opt.value = "./datasets/" + csv;
      opt.textContent = csv;
      select.appendChild(opt);
    }
    select.value = select.options[1]?.value || "custom";
  } else {
    select.value = "custom";
  }
  updateCsvInput();
}
function updateCsvInput() {
  const select = document.getElementById('csv_path_select');
  const input = document.getElementById('csv_path');
  if (select.value === "custom") {
    input.style.display = "";
    input.required = true;
    input.value = "";
  } else {
    input.style.display = "none";
    input.required = false;
    input.value = select.value;
  }
}
document.getElementById('csv_path_select').addEventListener('change', updateCsvInput);
window.addEventListener('DOMContentLoaded', fillDatasetDropdown);

/* ========= Custom model_dir input toggle ========= */
const modelDirSelect = document.getElementById('model_dir_select');
const modelDirInput = document.getElementById('model_dir');
const modelDirLabel = document.getElementById('model_dir_label');

modelDirSelect.addEventListener('change', function() {
  if (this.value === 'custom') {
    modelDirInput.style.display = '';
    modelDirLabel.style.display = '';
    modelDirInput.required = true;
    modelDirInput.value = '';
    modelDirInput.focus();
  } else {
    modelDirInput.style.display = 'none';
    modelDirLabel.style.display = 'none';
    modelDirInput.required = false;
    modelDirInput.value = '';
  }
});

/* ========= Training Submit (FIX: Backend-kompatibles Payload) ========= */
document.getElementById("settings").onsubmit = async e => {
  e.preventDefault();

  // Chart reset
  if (lossChart) {
    lossChart.data.labels = [];
    lossChart.data.datasets[0].data = [];
    lossChart.update('none');
  }
  window.lossData = [];
  window.lossSteps = [];

  const maxSteps = numberOrNull(document.getElementById("max_steps").value);

  const modelDir = (modelDirSelect.value === "custom" ? modelDirInput.value.trim() : modelDirSelect.value);
  if (!modelDir) { alert("Bitte model_dir angeben."); return; }

  const csvPath = (document.getElementById("csv_path").style.display !== "none")
    ? document.getElementById("csv_path").value.trim()
    : document.getElementById("csv_path_select").value;

  if (!csvPath) { alert("Bitte csv_path angeben."); return; }

  // ✅ Nur Felder senden, die dein FastAPI TrainConfig (Server) akzeptiert
  const payload = {
    model_dir: modelDir,
    csv_path: csvPath,
    save_dir: document.getElementById("save_dir").value.trim() || null,

    template_mode: document.getElementById("template_mode").value,
    column_name: document.getElementById("column_name").value.trim() || "text",

    learning_rate: parseFloat(document.getElementById("learning_rate").value),
    lr_schedule: document.getElementById("lr_schedule").value,

    per_device_train_batch_size: parseInt(document.getElementById("per_device_train_batch_size").value),
    gradient_accumulation_steps: parseInt(document.getElementById("gradient_accumulation_steps").value),

    num_train_epochs: parseFloat(document.getElementById("num_train_epochs").value || "3"),
    max_steps: (maxSteps !== null ? parseInt(String(maxSteps)) : null),

    max_seq_length: parseInt(document.getElementById("max_seq_length").value || "1024"),

    shuffle: document.getElementById("shuffle").checked,
    sort_by_length: document.getElementById("sort_by_length").checked,

    device: document.getElementById("device").value,

    train_mode: document.getElementById("train_mode").value,
    lora_r: parseInt(document.getElementById("lora_r").value || '8'),
    lora_alpha: parseInt(document.getElementById("lora_alpha").value || '16'),

    precision_mode: document.getElementById("precision_mode").value,
    gradient_checkpointing: document.getElementById("gradient_checkpointing").checked,

    dataloader_num_workers: 0,
    merge_lora_on_save: true,

    max_grad_norm: 1.0,
    weight_decay: 0.01,

    // N-Gramm
    use_ngrams: document.getElementById("use_ngrams").checked,
    ngram_max: parseInt(document.getElementById("ngram_max").value || "12"),
    ngram_top_k: parseInt(document.getElementById("ngram_top_k").value || "1500"),
    ngram_min_chars: parseInt(document.getElementById("ngram_min_chars").value || "16"),
    ngram_min_words: parseInt(document.getElementById("ngram_min_words").value || "2"),
    ngram_max_samples: parseInt(document.getElementById("ngram_max_samples").value || "4000"),
    ngram_budgeted: document.getElementById("ngram_budgeted").checked,
    ngram_target_fit: parseFloat(document.getElementById("ngram_target_fit").value || "0.98"),
    ngram_eval_samples: parseInt(document.getElementById("ngram_eval_samples").value || "512"),
    ngram_add_batch: parseInt(document.getElementById("ngram_add_batch").value || "64"),
    ngram_min_count: 2,
    ngram_max_token_chars: 384,
    ngram_max_tokens_per_text: 4096
  };

  const overlay = document.getElementById("matrix-spinner-overlay");
  overlay.style.display = "flex";
  try {
    const resp = await fetch("/start", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(payload)
    });

    const raw = await resp.text();
    let json;
    try { json = JSON.parse(raw); }
    catch { json = { error: "Server-Antwort war kein JSON", raw: raw.slice(0, 400) }; }

    if (!resp.ok || json.running === false) {
      alert("Fehler beim Starten des Trainings: " + (json.error || json.msg || ("HTTP " + resp.status)));
    } else if (json.msg) {
      alert(json.msg);
    }
  } catch (err) {
    alert("Fehler beim Start-Request: " + (err?.message || err));
  } finally {
    overlay.style.display = "none";
  }
};

document.getElementById("stopBtn").onclick = async function() {
  try { await fetch("/stop", {method: "POST"}); }
  catch {}
};

/* ========= Download Beispiel CSVs ========= */
window.downloadExample = function(mode) {
  let csvContent = "";
  if (mode === "text") {
    csvContent = `text
Das ist ein Beispielsatz für Pretraining.
Hier folgt eine weitere Trainingszeile.
`;
  } else {
    csvContent = `id,parent_id,system,Benutzer,Kontext,Assistentin
1,,Du bist ein freundlicher Chatbot.,Hallo!,,"Hallo! Wie kann ich dir helfen?"
2,1,,Wie spät ist es?,,"Ich habe keinen Zugriff auf deine Uhr, aber du kannst oben rechts schauen."
3,,Du bist Übersetzer.,Übersetze: "Guten Morgen",,Auf Englisch: "Good morning".
`;
  }
  const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.setAttribute("download", mode === "text" ? "text_beispiel.csv" : "row_sft_dialog_beispiel.csv");
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

/* ========= Chat UI ========= */
let chatMessages = [];
function renderChat() {
  const box = document.getElementById('chat_history');
  box.innerHTML = chatMessages.map(m => {
    const who = m.role === 'user' ? '<b>Du</b>' : '<b>Assistentin</b>';
    return `<div style="margin:0.3em 0;"><span style="color:#20ffa0;">${who}:</span> ${escapeHtmlWithBreaks(m.content)}</div>`;
  }).join('');
  box.scrollTop = box.scrollHeight;
}

async function loadChatModel() {
  const model = document.getElementById('chat_model_select').value || null;
  const device = document.getElementById('chat_device').value;
  const resp = await fetch('/load_inference', {
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ model_dir: model, device })
  });
  const j = await resp.json();
  alert(j.msg || j.error || 'geladen');
}

async function sendChat() {
  const inp = document.getElementById('chat_input');
  const sys = document.getElementById('chat_system').value.trim();
  const max_new = parseInt(document.getElementById('chat_max_new').value || '256');
  const temp = parseFloat(document.getElementById('chat_temp').value || '0.7');
  const top_p = parseFloat(document.getElementById('chat_topp').value || '0.9');

  const model = document.getElementById('chat_model_select').value || null;
  const device = document.getElementById('chat_device').value;

  const text = inp.value.trim();
  if (!text) return;

  chatMessages.push({ role: 'user', content: text });
  renderChat();
  inp.value = '';

  const req = {
    model_dir: model,
    device: device,
    system: sys || null,
    messages: chatMessages,
    max_new_tokens: max_new,
    temperature: temp,
    top_p: top_p,
    top_k: 50,
    repetition_penalty: 1.05,
    do_sample: true
  };

  const assistantMsg = { role: 'assistant', content: '' };
  chatMessages.push(assistantMsg);
  renderChat();

  try {
    const resp = await fetch('/chat_stream', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(req)
    });

    if (!resp.ok || !resp.body) throw new Error('Streaming nicht verfügbar');

    const reader = resp.body.getReader();
    const decoder = new TextDecoder('utf-8');

    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      assistantMsg.content += decoder.decode(value, { stream: true });
      renderChat();
    }
  } catch (err) {
    try {
      const r = await fetch('/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(req)
      });

      const rawText = await r.text();
      let j;

      try { j = JSON.parse(rawText); }
      catch {
        assistantMsg.content = '(Fehler: Chat-Antwort war kein gültiges JSON:\n' + rawText.slice(0, 400) + ')';
        renderChat();
        return;
      }

      if (!r.ok) { assistantMsg.content = '(Fehler: ' + (j.error || ('HTTP ' + r.status)) + ')'; renderChat(); return; }
      if (j.error) { assistantMsg.content = '(Fehler: ' + j.error + ')'; renderChat(); return; }

      assistantMsg.content = j.response || '';
      renderChat();
    } catch (e2) {
      assistantMsg.content = '(Fehler: ' + (e2.message || 'Unbekannt') + ')';
      renderChat();
    }
  }
}

document.getElementById('chat_send_btn').addEventListener('click', sendChat);
document.getElementById('chat_input').addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); sendChat(); }});
document.getElementById('chat_load_btn').addEventListener('click', loadChatModel);

/* Chat-Modelldropdown befüllen */
window.addEventListener('DOMContentLoaded', async () => {
  const sel = document.getElementById('chat_model_select');
  try{
    const res = await fetch('/available_models');
    const runs = await res.json();
    runs.reverse().forEach(folder => {
      const opt = document.createElement('option');
      opt.value = "./training_outputs/" + folder;
      opt.textContent = folder;
      sel.appendChild(opt);
    });
  } catch {}
});

async function unloadChatModel() {
  const btn = document.getElementById('chat_unload_btn');
  const sendBtn = document.getElementById('chat_send_btn');
  try {
    btn.disabled = true;
    sendBtn.disabled = true;
    const resp = await fetch('/unload_inference', { method: 'POST' });
    const j = await resp.json();
    chatMessages = [];
    renderChat();
    alert(j.msg || j.error || 'Inferenz-Modell entladen.');
  } catch (e) {
    alert('Entladen fehlgeschlagen: ' + (e?.message || e));
  } finally {
    btn.disabled = false;
    sendBtn.disabled = false;
  }
}
document.getElementById('chat_unload_btn').addEventListener('click', unloadChatModel);
</script>
</body>
</html>
